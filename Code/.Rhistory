Framenum <- data$Frame[i]
image <- image_read(paste("../Data/Frames/",data$FileName[i],"/",Framenum,".jpg", sep=""))
#crop image:
cropimage <- image_crop(image,paste(data$w[i]*1.5,"x",data$h[i]*1.5,"+",data$x[i],"+",data$y[i], sep=""))
#add black border around cropped image#
#get desired height and width:
ht <- 720/imagescale
wt <- 1280/imagescale
cropimagedim <- dim(cropimage[[1]])
#scale image according to size of crop
if(isTRUE(cropimagedim[3]>cropimagedim[2])){#if height of image > width
if(cropimagedim[3]>ht) {cropscale <- image_scale(cropimage, paste("x",ht, sep=""))}else{
cropscale<- cropimage} #scale to height, only if the height is larger than desired height
}else{
if(cropimagedim[2]>wt){cropscale <- image_scale(cropimage, paste(wt, sep=""))}else{
cropscale <- cropimage} #scale to width
}
scaledimagedim <- dim(cropscale[[1]]) #get dimension of scaled image
#add border:
cropborder <- image_border(cropscale,"black", geometry = paste((wt-scaledimagedim[2])/2,"x",(ht-scaledimagedim[3])/2, sep=""))
#sometimes, pixel values are not perfect, need to rescale again
finalimage <- image_scale(cropborder, paste(wt,"x",ht,"!",sep=""))
# browser()
plot(finalimage)
#save to array:
ImageVal[i,,,] <- as.integer(finalimage[[1]])/255
}
save(ImageVal, file=paste("../Data/",FileName,"_Array.rda", sep=""))
save(ImageVal, file=paste("../Data/Arrays/",FileName,"_Array.rda", sep=""))
#Takes long/ short format and compares with excel file to generate training/ verification files
rm(list=ls())
FileName <- "VT0115_S1_VP7_20190607"
Short <- read.csv(paste("../Data/Frames/",FileName,"/FramesShort.csv", sep=""))
View(Short)
manual <- read.csv(paste("../Data/Frames/",FileName,"/",FileName,"_MeerkatManual.csv"))
manual <- read.csv(paste("../Data/Frames/",FileName,"/",FileName,"_MeerkatManual.csv", sep=""))
View(manual)
?split
VidCode <- split(FileName, sep="_")
VidCode <- strsplit(FileName, "_")
VidCode <- strsplit(FileName, "_")[1]
View(VidCode)
VidCode <- strsplit(FileName, "_")[[1]]
VidCode <- strsplit(FileName, "_")[[1]][1]
Short <- read.csv(paste("../Data/Frames/",FileName,"/FramesShort.csv", sep=""))
library(readxl)
Year <- "2005"
excel <- read_excel(paste("../Data/Excel/DVDs ",Year,"/",VidCode,".xlsx", sep=""))
FileName <- "VO0006_VP7_LM40_20150501"
VidCode <- strsplit(FileName, "_")[[1]][1]
Year <- "2015"
Short <- read.csv(paste("../Data/Frames/",FileName,"/FramesShort.csv", sep=""))
excel <- read_excel(paste("../Data/Excel/DVDs ",Year,"/",VidCode,".xlsx", sep=""))
View(excel)
View(Short)
#round to decimal
Short$Round <- round(Short$MeanTime, digits = 1)
FemVal <- c(excel$`F in`,excel$`F out`)
FemValIn <- excel$`F in`
FemValIn <- na.omit(excel$`F in`)
FemValOut <- na.omit(excel$`F in`)
FemValOut <- na.omit(excel$`F out`)
#round to decimal
Short$Round <- round(Short$MeanTime, digits = 1)
FemValIn <- na.omit(excel$`F in`)
FemValOut <- na.omit(excel$`F out`)
MalValIn <- na.omit(excel$`M in`)
MalValOut <- na.omit(excel$`M out`)
#Takes long/ short format and compares with excel file to generate training/ verification files
rm(list=ls())
library(readxl)
FileName <- "VO0006_VP7_LM40_20150501"
VidCode <- strsplit(FileName, "_")[[1]][1]
Year <- "2015"
Short <- read.csv(paste("../Data/Frames/",FileName,"/FramesShort.csv", sep=""))
excel <- read_excel(paste("../Data/Excel/DVDs ",Year,"/",VidCode,".xlsx", sep=""))
#round to decimal
Short$Time <- round(Short$MeanTime, digits = 1)
FemValIn <- na.omit(excel$`F in`)
FemValOut <- na.omit(excel$`F out`)
MalValIn <- na.omit(excel$`M in`)
MalValOut <- na.omit(excel$`M out`)
mergedf <- data.frame(Time=c(FemValIn,FemValOut,MalValIn,MalValOut),
Sex=c(rep(0,length(FemValIn)+length(FemValOut),
rep(1,length(MalValIn)+length(MalValOut)))),
Event=c(rep("In",length(FemValIn)), rep("Out", length(FemValOut)),
rep("In",length(MalValIn)), rep("Out",length(MalValOut))))
length(FemValIn)+length(FemValOut)
?rep
View(mergedf)
mergedf <- data.frame(Time=c(FemValIn,FemValOut,MalValIn,MalValOut),
Sex=c(rep(0,length(FemValIn)+length(FemValOut)),
rep(1,length(MalValIn)+length(MalValOut))),
Event=c(rep("In",length(FemValIn)), rep("Out", length(FemValOut)),
rep("In",length(MalValIn)), rep("Out",length(MalValOut))))
View(mergedf)
yo <- merge(Short,mergedf)
View(yo)
yo <- merge(Short,mergedf, all=T)
View(yo)
mergedf <- data.frame(Time=c(FemValIn,FemValOut,MalValIn,MalValOut),
Sex=c(rep(0,length(FemValIn)+length(FemValOut)),
rep(1,length(MalValIn)+length(MalValOut))),
EventDes=c(rep("In",length(FemValIn)), rep("Out", length(FemValOut)),
rep("In",length(MalValIn)), rep("Out",length(MalValOut))))
yo <- merge(Short,mergedf, all=T)
library(DescTools)
library(DescTools)
i <- 1
DescTools::Closest(Short$MeanTime, mergedf$Time[i], which=TRUE)
Short$Sex <- NA
Short$EventDes <- NA
names(Short)
#is empty, can replace with new data
Short[Closeindex,names(Short) %in% c("Sex","EventDes")]
Closeindex <- DescTools::Closest(Short$MeanTime, mergedf$Time[i], which=TRUE) #find which time is closest
#is empty, can replace with new data
Short[Closeindex,names(Short) %in% c("Sex","EventDes")]
#is empty, can replace with new data
Short[Closeindex,names(Short) %in% c("Sex","EventDes")] <- mergedf[i, names(mergedf) %in%c("Sex","EventDes") ]
if(is.na(Short$Sex[Closeindex])==TRUE)
#check if there is duplicates:
if(is.na(Short$Sex[Closeindex])==TRUE){
#is empty, can replace with new data
Short[Closeindex,names(Short) %in% c("Sex","EventDes")] <- mergedf[i, names(mergedf) %in%c("Sex","EventDes") ]
}else{
#not empty, duplicate row
}
#check if there is duplicates:
if(is.na(Short$Sex[Closeindex])){
#is empty, can replace with new data
Short[Closeindex,names(Short) %in% c("Sex","EventDes")] <- mergedf[i, names(mergedf) %in%c("Sex","EventDes") ]
}else{
#not empty, duplicate row
}
#not empty, duplicate then add a row
Short[nrow(Short)+1, ] <- Short[Closeindex,]
#not empty, duplicate then add a row
newIndex <- nrow(Short) +1
Short[newIndex, ] <- Short[Closeindex,]
#Takes long/ short format and compares with excel file to generate training/ verification files
rm(list=ls())
library(readxl)
library(DescTools)
FileName <- "VO0006_VP7_LM40_20150501"
VidCode <- strsplit(FileName, "_")[[1]][1]
Year <- "2015"
Short <- read.csv(paste("../Data/Frames/",FileName,"/FramesShort.csv", sep=""))
excel <- read_excel(paste("../Data/Excel/DVDs ",Year,"/",VidCode,".xlsx", sep=""))
#round to decimal
Short$Time <- round(Short$MeanTime, digits = 1)
FemValIn <- na.omit(excel$`F in`)
FemValOut <- na.omit(excel$`F out`)
MalValIn <- na.omit(excel$`M in`)
MalValOut <- na.omit(excel$`M out`)
mergedf <- data.frame(Time=c(FemValIn,FemValOut,MalValIn,MalValOut),
Sex=c(rep(0,length(FemValIn)+length(FemValOut)),
rep(1,length(MalValIn)+length(MalValOut))),
EventDes=c(rep("In",length(FemValIn)), rep("Out", length(FemValOut)),
rep("In",length(MalValIn)), rep("Out",length(MalValOut))))
Short$Sex <- NA
Short$EventDes <- NA
for(i in 1:nrow(mergedf)){
Closeindex <- DescTools::Closest(Short$MeanTime, mergedf$Time[i], which=TRUE) #find which time is closest
#check if there is duplicates:
if(is.na(Short$Sex[Closeindex])){
#is empty, can replace with new data
Short[Closeindex,names(Short) %in% c("Sex","EventDes")] <- mergedf[i, names(mergedf) %in%c("Sex","EventDes") ]
}else{
#not empty, duplicate then add a row
newIndex <- nrow(Short) +1
Short[newIndex, ] <- Short[Closeindex,]
Short[newIndex,names(Short) %in% c("Sex","EventDes")] <- mergedf[i, names(mergedf) %in%c("Sex","EventDes") ]
}
}
View(Short)
View(mergedf)
#Takes long/ short format and compares with excel file to generate training/ verification files
rm(list=ls())
library(readxl)
library(DescTools)
FileName <- "VO0006_VP7_LM40_20150501"
VidCode <- strsplit(FileName, "_")[[1]][1]
Year <- "2015"
Short <- read.csv(paste("../Data/Frames/",FileName,"/FramesShort.csv", sep=""))
excel <- read_excel(paste("../Data/Excel/DVDs ",Year,"/",VidCode,".xlsx", sep=""))
#round to decimal
FemValIn <- na.omit(excel$`F in`)
FemValOut <- na.omit(excel$`F out`)
MalValIn <- na.omit(excel$`M in`)
MalValOut <- na.omit(excel$`M out`)
mergedf <- data.frame(Time=c(FemValIn,FemValOut,MalValIn,MalValOut),
Sex=c(rep(0,length(FemValIn)+length(FemValOut)),
rep(1,length(MalValIn)+length(MalValOut))),
EventDes=c(rep("In",length(FemValIn)), rep("Out", length(FemValOut)),
rep("In",length(MalValIn)), rep("Out",length(MalValOut))))
Short$Time <- NA
Short$Sex <- NA
Short$EventDes <- NA
for(i in 1:nrow(mergedf)){
Closeindex <- DescTools::Closest(Short$MeanTime, mergedf$Time[i], which=TRUE) #find which time is closest
#check if there is duplicates:
if(is.na(Short$Sex[Closeindex])){
#is empty, can replace with new data
Short[Closeindex,names(Short) %in% c("Time","Sex","EventDes")] <- mergedf[i, names(mergedf) %in%c("Time","Sex","EventDes") ]
}else{
#not empty, duplicate then add a row
newIndex <- nrow(Short) +1
Short[newIndex, ] <- Short[Closeindex,]
Short[newIndex,names(Short) %in% c("Time","Sex","EventDes")] <- mergedf[i, names(mergedf) %in%c("Time","Sex","EventDes") ]
}
}
View(Short)
View(excel)
View(Short)
#Convert Short back to Long
Long <- read.csv(paste("../Data/Frames/",FileName,"/FramesLong.csv", sep=""))
View(Long)
View(Short)
names(Short)
ShortMerge <- Short[,names(Short) %in% c("Sex","EventDes")]
yo <- merge(Long,ShortMerge)
View(yo)
yo <- merge(Long,ShortMerge, by = "Event")
yo <- merge(Long,ShortMerge, by = Event)
yo <- merge(Long,ShortMerge, by = "Event")
yo <- merge(Long,ShortMerge, by=c("Event"))
yo <- merge(Long,ShortMerge, by=c("Event","Event"))
yo <- merge(Long,ShortMerge,by.x = "Event", by.y = "Event"))
yo <- merge(Long,ShortMerge,by.x = "Event", by.y = "Event")
ShortMerge <- Short[,names(Short) %in% c("Event","Sex","EventDes")]
yo <- merge(Long,ShortMerge,by="Event")
View(yo)
ShortMerge <- ShortMerge[-which(duplicated(ShortMerge$Event)),]
View(ShortMerge)
#Convert Short back to Long
Long <- read.csv(paste("../Data/Frames/",FileName,"/FramesLong.csv", sep=""))
ShortMerge <- Short[,names(Short) %in% c("Event","Sex","EventDes")]
ShortMerge <- ShortMerge[-which(duplicated(ShortMerge$Event)),]
yo <- merge(Long,ShortMerge,by="Event")
View(yo)
yo <- merge(Long,ShortMerge,by="Event", all=T)
View(yo)
NewLong <- merge(Long,ShortMerge,by="Event", all=T)
View(Short)
write.csv(Short, file=paste("../Data/Frames/",FileName,"/FramesShortCoded.csv", sep=""))
write.csv(NewLong, file=paste("../Data/Frames/",FileName,"/FramesLongCoded.csv", sep=""))
FileName <- "VT0139_S1_VP11_20190611"
source('~/Documents/SparrowVis/Code/GenerateTraining.R')
FileName <- "VO0006_VP7_LM40_20150501"
VidCode <- strsplit(FileName, "_")[[1]][1]# code for excel
Year <- "2015"
CodefrmExcel(FileName,VidCode,Year)
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
imagescale <- 4
ImageVal <- array(data=NA, dim=c(nrow(data),1280/imagescale,720/imagescale,3))
for(i in 1:nrow(data)){
Framenum <- data$Frame[i]
image <- image_read(paste("../Data/Frames/",data$FileName[i],"/",Framenum,".jpg", sep=""))
#crop image:
cropimage <- image_crop(image,paste(data$w[i]*1.5,"x",data$h[i]*1.5,"+",data$x[i],"+",data$y[i], sep=""))
#add black border around cropped image#
#get desired height and width:
ht <- 720/imagescale
wt <- 1280/imagescale
cropimagedim <- dim(cropimage[[1]])
#scale image according to size of crop
if(isTRUE(cropimagedim[3]>cropimagedim[2])){#if height of image > width
if(cropimagedim[3]>ht) {cropscale <- image_scale(cropimage, paste("x",ht, sep=""))}else{
cropscale<- cropimage} #scale to height, only if the height is larger than desired height
}else{
if(cropimagedim[2]>wt){cropscale <- image_scale(cropimage, paste(wt, sep=""))}else{
cropscale <- cropimage} #scale to width
}
scaledimagedim <- dim(cropscale[[1]]) #get dimension of scaled image
#add border:
cropborder <- image_border(cropscale,"black", geometry = paste((wt-scaledimagedim[2])/2,"x",(ht-scaledimagedim[3])/2, sep=""))
#sometimes, pixel values are not perfect, need to rescale again
finalimage <- image_scale(cropborder, paste(wt,"x",ht,"!",sep=""))
# browser()
plot(finalimage)
#save to array:
ImageVal[i,,,] <- as.integer(finalimage[[1]])/255
}
View(data)
data <- na.omit(data$Sex)
data <- na.omit(data, data$Sex)
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
data <- na.omit(data, data$Sex)
View(data)
imagescale <- 4
ImageVal <- array(data=NA, dim=c(nrow(data),1280/imagescale,720/imagescale,3))
for(i in 1:nrow(data)){
Framenum <- data$Frame[i]
image <- image_read(paste("../Data/Frames/",data$FileName[i],"/",Framenum,".jpg", sep=""))
#crop image:
cropimage <- image_crop(image,paste(data$w[i]*1.5,"x",data$h[i]*1.5,"+",data$x[i],"+",data$y[i], sep=""))
#add black border around cropped image#
#get desired height and width:
ht <- 720/imagescale
wt <- 1280/imagescale
cropimagedim <- dim(cropimage[[1]])
#scale image according to size of crop
if(isTRUE(cropimagedim[3]>cropimagedim[2])){#if height of image > width
if(cropimagedim[3]>ht) {cropscale <- image_scale(cropimage, paste("x",ht, sep=""))}else{
cropscale<- cropimage} #scale to height, only if the height is larger than desired height
}else{
if(cropimagedim[2]>wt){cropscale <- image_scale(cropimage, paste(wt, sep=""))}else{
cropscale <- cropimage} #scale to width
}
scaledimagedim <- dim(cropscale[[1]]) #get dimension of scaled image
#add border:
cropborder <- image_border(cropscale,"black", geometry = paste((wt-scaledimagedim[2])/2,"x",(ht-scaledimagedim[3])/2, sep=""))
#sometimes, pixel values are not perfect, need to rescale again
finalimage <- image_scale(cropborder, paste(wt,"x",ht,"!",sep=""))
# browser()
plot(finalimage)
#save to array:
ImageVal[i,,,] <- as.integer(finalimage[[1]])/255
}
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
data <- na.omit(data, data$Sex)
imagescale <- 4
ImageVal <- array(data=NA, dim=c(nrow(data),1280/imagescale,720/imagescale,3))
for(i in 1:nrow(data)){
Framenum <- data$Frame[i]
image <- image_read(paste("../Data/Frames/",data$FileName[i],"/",Framenum,".jpg", sep=""))
#crop image:
cropimage <- image_crop(image,paste(data$w[i]*1.3,"x",data$h[i]*1.3,"+",data$x[i],"+",data$y[i], sep=""))
#add black border around cropped image#
#get desired height and width:
ht <- 720/imagescale
wt <- 1280/imagescale
cropimagedim <- dim(cropimage[[1]])
#scale image according to size of crop
if(isTRUE(cropimagedim[3]>cropimagedim[2])){#if height of image > width
if(cropimagedim[3]>ht) {cropscale <- image_scale(cropimage, paste("x",ht, sep=""))}else{
cropscale<- cropimage} #scale to height, only if the height is larger than desired height
}else{
if(cropimagedim[2]>wt){cropscale <- image_scale(cropimage, paste(wt, sep=""))}else{
cropscale <- cropimage} #scale to width
}
scaledimagedim <- dim(cropscale[[1]]) #get dimension of scaled image
#add border:
cropborder <- image_border(cropscale,"black", geometry = paste((wt-scaledimagedim[2])/2,"x",(ht-scaledimagedim[3])/2, sep=""))
#sometimes, pixel values are not perfect, need to rescale again
finalimage <- image_scale(cropborder, paste(wt,"x",ht,"!",sep=""))
# browser()
plot(finalimage)
#save to array:
ImageVal[i,,,] <- as.integer(finalimage[[1]])/255
}
#reads long format data, crops image, then saves array
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
data <- na.omit(data, data$Sex)
# Run and process all files to prepare for training CNN on HPC cluster
rm(list=ls())
# Run and process all files to prepare for training CNN on HPC cluster
rm(list=ls())
source("ProcessFrameInfo.R")
source("GenerateTraining.R")
source("ProcessImages.R")
source("GenerateTraining.R")
source("ProcessImages.R")
source("ProcessFrameInfo.R")
source("GenerateTraining.R")
source("ProcessImages.R")
# Run and process all files to prepare for training CNN on HPC cluster
rm(list=ls())
source("ProcessFrameInfo.R")
source("GenerateTraining.R")
source("ProcessImages.R")
FileName <- "VO0068_VP11_F3_20150525"
Process_framecsv(FileName)
VidCode <- strsplit(FileName,"_")[[1]][1]
CodefrmExcel(FileName,VidCode, Year = "2015" )
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
View(data)
data <- na.omit(data,data$Sex)
ProcessImage(FileName, data)
View(data)
load("/home/alex2/Documents/SparrowVis/Data/Arrays/VO0068_VP11_F3_20150525_Array.rda")
ImageID <- data$Sex
save(ImageID, file=paste("../Data/Arrays/",FileName,"_ImageID.rda", sep=""))
rm(ImageID)
load("/home/alex2/Documents/SparrowVis/Data/Arrays/VO0068_VP11_F3_20150525_ImageID.rda")
library(keras)
#Building CNN structure and saving it
CNN <- keras_model_sequential()
CNN %>% layer_conv_2d(filters=30, kernel_size=c(4,4), activation = 'relu',
input_shape=c(1280/imagescale,720/imagescale,3), data_format="channels_last") %>%
layer_max_pooling_2d(pool_size = c(3,3)) %>%
layer_flatten() %>%
layer_dense(units=30, activation = 'relu')%>%
#layer_dense(units=15, activation='relu')%>%
#layer_dropout(rate=0.25) %>%
layer_dense(units=2, activation='softmax')%>%
compile(
optimizer='adam',
loss='sparse_categorical_crossentropy',
metrics=c('accuracy')
)
#Building CNN structure and saving it
imagescale <- 4
CNN <- keras_model_sequential()
CNN %>% layer_conv_2d(filters=30, kernel_size=c(4,4), activation = 'relu',
input_shape=c(1280/imagescale,720/imagescale,3), data_format="channels_last") %>%
layer_max_pooling_2d(pool_size = c(3,3)) %>%
layer_flatten() %>%
layer_dense(units=30, activation = 'relu')%>%
#layer_dense(units=15, activation='relu')%>%
#layer_dropout(rate=0.25) %>%
layer_dense(units=2, activation='softmax')%>%
compile(
optimizer='adam',
loss='sparse_categorical_crossentropy',
metrics=c('accuracy')
)
CNN <- keras_model_sequential()
CNN %>% layer_conv_2d(filters=30, kernel_size=c(4,4), activation = 'relu',
input_shape=c(1280/imagescale,720/imagescale,3), data_format="channels_last") %>%
layer_max_pooling_2d(pool_size = c(3,3)) %>%
layer_flatten() %>%
layer_dense(units=30, activation = 'relu')%>%
#layer_dense(units=15, activation='relu')%>%
#layer_dropout(rate=0.25) %>%
layer_dense(units=2, activation='softmax')%>%
compile(
optimizer='adam',
loss='sparse_categorical_crossentropy',
metrics=c('accuracy')
)
CNN %>% save_model_hdf5("../Data/Arrays/EmptyCNN")
Files <- list.files("../Data/Frames")
Files
Files <- Files[1:10]
Files
# Run and process all files to prepare for training CNN on HPC cluster
rm(list=ls())
library(keras)
source("ProcessFrameInfo.R")
source("GenerateTraining.R")
source("ProcessImages.R")
Files <- list.files("../Data/Frames")
Files <- Files[1:10]
for(i in 1:length(Files)){
FileName <- Files[i]
VidCode <- strsplit(FileName,"_")[[1]][1]
Process_framecsv(FileName)
CodefrmExcel(FileName,VidCode, Year = "2015")
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
data <- na.omit(data,data$Sex)
ProcessImage(FileName, data)
ImageID <- data$Sex
save(ImageID, file=paste("../Data/Arrays/",FileName,"_ImageID.rda", sep=""))
}
ImageID
View(data)
# Run and process all files to prepare for training CNN on HPC cluster
rm(list=ls())
library(keras)
source("ProcessFrameInfo.R")
source("GenerateTraining.R")
source("ProcessImages.R")
Files <- list.files("../Data/Frames")
Files <- Files[1:10]
for(i in 1:length(Files)){
browser()
FileName <- Files[i]
VidCode <- strsplit(FileName,"_")[[1]][1]
Process_framecsv(FileName)
CodefrmExcel(FileName,VidCode, Year = "2015")
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
data <- na.omit(data,data$Sex)
ProcessImage(FileName, data)
ImageID <- data$Sex
save(ImageID, file=paste("../Data/Arrays/",FileName,"_ImageID.rda", sep=""))
}
?Closest
# Run and process all files to prepare for training CNN on HPC cluster
rm(list=ls())
library(keras)
source("ProcessFrameInfo.R")
source("GenerateTraining.R")
source("ProcessImages.R")
Files <- list.files("../Data/Frames")
Files <- Files[1:10]
for(i in 1:length(Files)){
browser()
FileName <- Files[i]
VidCode <- strsplit(FileName,"_")[[1]][1]
Process_framecsv(FileName)
CodefrmExcel(FileName,VidCode, Year = "2015")
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
data <- na.omit(data,data$Sex)
ProcessImage(FileName, data)
ImageID <- data$Sex
save(ImageID, file=paste("../Data/Arrays/",FileName,"_ImageID.rda", sep=""))
}
for(i in 1:length(Files)){
#browser()
FileName <- Files[i]
VidCode <- strsplit(FileName,"_")[[1]][1]
Process_framecsv(FileName)
CodefrmExcel(FileName,VidCode, Year = "2015")
data <- read.csv(paste("../Data/Frames/",FileName,"/","FramesLongCoded.csv", sep=""))
data <- na.omit(data,data$Sex)
ProcessImage(FileName, data)
ImageID <- data$Sex
save(ImageID, file=paste("../Data/Arrays/",FileName,"_ImageID.rda", sep=""))
}
q()
